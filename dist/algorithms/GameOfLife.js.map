{"version":3,"sources":["GameOfLife.js"],"names":["Algorithm","Node","GameOfLife","constructor","nodes","super","this","rows","stateManager","getRows","cols","getCols","get_1d_index","row","col","solve","generation","i","nextState","map","node","currentCell","aliveNeighbors","countAliveNeighbors","is_wall","push","type","index","steps","count","dx","dy","newRow","newCol"],"mappings":"OAAOA,cAAe,wBACfC,SAAU,iCAEF,MAAMC,mBAAmBF,UACpCG,WAAAA,CAAYC,GACRC,MAAMD,GACNE,KAAKC,KAAOD,KAAKE,aAAaC,UAC9BH,KAAKI,KAAOJ,KAAKE,aAAaG,UAC9BL,KAAKM,aAAe,CAACC,EAAKC,IAAQD,EAAMP,KAAKI,KAAOI,CACvD,CAEDC,KAAAA,GACI,MAAMC,EAAa,GACnB,IAAK,IAAIC,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMC,EAAYZ,KAAKF,MAAMe,KAAKC,GACvB,IAAInB,KAAKmB,EAAKP,IAAKO,EAAKN,KAAK,GAAO,KAE/C,IAAK,IAAID,EAAM,EAAGA,EAAMP,KAAKC,KAAMM,IAC/B,IAAK,IAAIC,EAAM,EAAGA,EAAMR,KAAKI,KAAMI,IAAO,CACtC,MAAMO,EAAcf,KAAKF,MAAME,KAAKM,aAAaC,EAAKC,IAChDQ,EAAiBhB,KAAKiB,oBAAoBV,EAAKC,GAEjDO,EAAYG,QACRF,EAAiB,GAAKA,EAAiB,GACvCJ,EACIZ,KAAKM,aAAaC,EAAKC,IACzBU,SAAU,EACZR,EAAWS,KAAK,CACZC,KAAM,OACNC,MAAOrB,KAAKM,aAAaC,EAAKC,OAGlCI,EACIZ,KAAKM,aAAaC,EAAKC,IACzBU,SAAU,EACZR,EAAWS,KAAK,CACZC,KAAM,SACNC,MAAOrB,KAAKM,aAAaC,EAAKC,MAIf,IAAnBQ,IACAJ,EACIZ,KAAKM,aAAaC,EAAKC,IACzBU,SAAU,EACZR,EAAWS,KAAK,CACZC,KAAM,SACNC,MAAOrB,KAAKM,aAAaC,EAAKC,KAI7C,CAGLR,KAAKsB,MAAMH,KAAK,CAAEC,KAAM,gBAAiBV,eAEzCV,KAAKF,MAAQc,CAChB,CAED,OAAOZ,KAAKsB,KACf,CAEDL,mBAAAA,CAAoBV,EAAKC,GACrB,IAAIe,EAAQ,EAEZ,IAAK,IAAIC,GAAM,EAAGA,GAAM,EAAGA,IACvB,IAAK,IAAIC,GAAM,EAAGA,GAAM,EAAGA,IAAM,CAC7B,GAAW,IAAPD,GAAmB,IAAPC,EACZ,SAGJ,MAAMC,GAAUnB,EAAMiB,EAAKxB,KAAKC,MAAQD,KAAKC,KACvC0B,GAAUnB,EAAMiB,EAAKzB,KAAKI,MAAQJ,KAAKI,KAGzCJ,KAAKF,MAAME,KAAKM,aAAaoB,EAAQC,IAExBT,SACbK,GAEP,CAGL,OAAOA,CACV","file":"GameOfLife.js","sourcesContent":["import Algorithm from \"./Algorithm.js\";\nimport Node from \"../node/Node.js\";\n\nexport default class GameOfLife extends Algorithm {\n    constructor(nodes) {\n        super(nodes);\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n        this.get_1d_index = (row, col) => row * this.cols + col;\n    }\n\n    solve() {\n        const generation = [];\n        for (let i = 0; i < 10; i++) {\n            const nextState = this.nodes.map((node) => {\n                return new Node(node.row, node.col, false, false);\n            });\n            for (let row = 0; row < this.rows; row++) {\n                for (let col = 0; col < this.cols; col++) {\n                    const currentCell = this.nodes[this.get_1d_index(row, col)];\n                    const aliveNeighbors = this.countAliveNeighbors(row, col);\n\n                    if (currentCell.is_wall) {\n                        if (aliveNeighbors < 2 || aliveNeighbors > 3) {\n                            nextState[\n                                this.get_1d_index(row, col)\n                            ].is_wall = false;\n                            generation.push({\n                                type: \"kill\",\n                                index: this.get_1d_index(row, col),\n                            });\n                        } else {\n                            nextState[\n                                this.get_1d_index(row, col)\n                            ].is_wall = true;\n                            generation.push({\n                                type: \"unkill\",\n                                index: this.get_1d_index(row, col),\n                            });\n                        }\n                    } else {\n                        if (aliveNeighbors === 3) {\n                            nextState[\n                                this.get_1d_index(row, col)\n                            ].is_wall = true;\n                            generation.push({\n                                type: \"unkill\",\n                                index: this.get_1d_index(row, col),\n                            });\n                        }\n                    }\n                }\n            }\n\n            this.steps.push({ type: \"golGeneration\", generation });\n\n            this.nodes = nextState;\n        }\n\n        return this.steps;\n    }\n\n    countAliveNeighbors(row, col) {\n        let count = 0;\n\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                if (dx === 0 && dy === 0) {\n                    continue;\n                }\n\n                const newRow = (row + dx + this.rows) % this.rows;\n                const newCol = (col + dy + this.cols) % this.cols;\n\n                const neighborCell =\n                    this.nodes[this.get_1d_index(newRow, newCol)];\n\n                if (neighborCell.is_wall) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n}\n"]}