import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class Dijkstra extends Algorithm{constructor(s){super(s),this.rows=this.stateManager.getRows(),this.cols=this.stateManager.getCols(),this.startNode=s.find((s=>s.is_start)),this.finishNode=s.find((s=>s.is_finish)),this.get_1d_index=(s,t)=>s*this.cols+t}solve(){for(let s of this.nodes)s.distance=1/0,s.is_visited=!1,s.prev=null;this.startNode.distance=0;let s=this.nodes.slice();for(;s.length;){this.sortByDistance(s);let t=s.shift(),i=this.get_1d_index(t.row,t.col);if(!t.is_wall){if(t.distance==1/0)break;if(t.is_visited=!0,this.steps.push({type:"visited",indices:[i]}),t==this.finishNode)break;this.updateNeighbors(t,this.nodes)}}this.steps.push({type:"finish",indices:this.dijkstraGetPath()});for(let s of this.nodes)s.distance=1/0,s.is_visited=!1,s.prev=null;return this.steps}dijkstraGetPath(s=this.finishNode){const t=[];let i=s;for(;null!==i;)t.unshift(this.get_1d_index(i.row,i.col)),i=i.prev;return t}updateNeighbors(s,t){let i=this.getNeighbors(s,t);for(let t of i){if(s.distance+1<t.distance){const i=this.get_1d_index(t.row,t.col);t.distance=s.distance+1,t.prev=s,this.steps.push({type:"updated",indices:[i]})}}}getNeighbors(s,t){const i=[];let e=s.row,d=s.col,h=this.rows,o=this.cols;return e>0&&i.push(t[this.get_1d_index(e-1,d)]),e<h-1&&i.push(t[this.get_1d_index(e+1,d)]),d>0&&i.push(t[this.get_1d_index(e,d-1)]),d<o-1&&i.push(t[this.get_1d_index(e,d+1)]),i.filter((s=>!s.is_visited&&!s.is_wall))}sortByDistance(s){s.sort(((s,t)=>s.distance-t.distance))}}
//# sourceMappingURL=dijkstra.js.map