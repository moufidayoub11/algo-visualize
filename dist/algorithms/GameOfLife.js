import Algorithm from"./Algorithm.js";import Node from"../node/Node.js";export default class GameOfLife extends Algorithm{constructor(t){super(t),this.rows=this.stateManager.getRows(),this.cols=this.stateManager.getCols(),this.get_1d_index=(t,s)=>t*this.cols+s}solve(){const t=[];for(let s=0;s<10;s++){const s=this.nodes.map((t=>new Node(t.row,t.col,!1,!1)));for(let e=0;e<this.rows;e++)for(let i=0;i<this.cols;i++){const o=this.nodes[this.get_1d_index(e,i)],l=this.countAliveNeighbors(e,i);o.is_wall?l<2||l>3?(s[this.get_1d_index(e,i)].is_wall=!1,t.push({type:"kill",index:this.get_1d_index(e,i)})):(s[this.get_1d_index(e,i)].is_wall=!0,t.push({type:"unkill",index:this.get_1d_index(e,i)})):3===l&&(s[this.get_1d_index(e,i)].is_wall=!0,t.push({type:"unkill",index:this.get_1d_index(e,i)}))}this.steps.push({type:"golGeneration",generation:t}),this.nodes=s}return this.steps}countAliveNeighbors(t,s){let e=0;for(let i=-1;i<=1;i++)for(let o=-1;o<=1;o++){if(0===i&&0===o)continue;const l=(t+i+this.rows)%this.rows,n=(s+o+this.cols)%this.cols;this.nodes[this.get_1d_index(l,n)].is_wall&&e++}return e}}
//# sourceMappingURL=GameOfLife.js.map