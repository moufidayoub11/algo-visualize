{"version":3,"sources":["dijkstra.js"],"names":["Node","Algorithm","Dijkstra","constructor","nodes","super","this","rows","stateManager","getRows","cols","getCols","startNode","find","node","is_start","finishNode","is_finish","get_1d_index","row","col","solve","distance","Infinity","is_visited","prev","unvisited_list","slice","length","sortByDistance","closest","shift","closestIndex","is_wall","steps","push","type","indices","updateNeighbors","dijkstraGetPath","current","shortestPath","curr","unshift","neighbors","getNeighbors","neigh","index","filter","ng_node","sort","node1","node2"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,iBAAiBD,UAElCE,WAAAA,CAAYC,GACRC,MAAMD,GAENE,KAAKC,KAAOD,KAAKE,aAAaC,UAC9BH,KAAKI,KAAOJ,KAAKE,aAAaG,UAC9BL,KAAKM,UAAYR,EAAMS,MAAMC,GAASA,EAAKC,WAC3CT,KAAKU,WAAaZ,EAAMS,MAAMC,GAASA,EAAKG,YAC5CX,KAAKY,aAAe,CAACC,EAAKC,IAAQD,EAAMb,KAAKI,KAAOU,CACvD,CAEDC,KAAAA,GACI,IAAK,IAAIP,KAAQR,KAAKF,MAClBU,EAAKQ,SAAWC,IAChBT,EAAKU,YAAa,EAClBV,EAAKW,KAAO,KAEhBnB,KAAKM,UAAUU,SAAW,EAE1B,IAAII,EAAiBpB,KAAKF,MAAMuB,QAEhC,KAASD,EAAeE,QAAQ,CAC5BtB,KAAKuB,eAAeH,GACpB,IAAII,EAAUJ,EAAeK,QACzBC,EAAe1B,KAAKY,aAAaY,EAAQX,IAAKW,EAAQV,KAE1D,IAAIU,EAAQG,QAAZ,CACA,GAAIH,EAAQR,UAAYC,IAAU,MAMlC,GAJAO,EAAQN,YAAa,EAErBlB,KAAK4B,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACL,KAEzCF,GAAWxB,KAAKU,WAAY,MAEhCV,KAAKgC,gBAAgBR,EAASxB,KAAKF,MATd,CAUxB,CAEDE,KAAK4B,MAAMC,KAAK,CAAEC,KAAM,SAAUC,QAAS/B,KAAKiC,oBAEhD,IAAK,IAAIzB,KAAQR,KAAKF,MAClBU,EAAKQ,SAAWC,IAChBT,EAAKU,YAAa,EAClBV,EAAKW,KAAO,KAEhB,OAAOnB,KAAK4B,KACf,CAEDK,eAAAA,CAAgBC,EAAUlC,KAAKU,YAC3B,MAAMyB,EAAe,GACrB,IAAIC,EAAOF,EAEX,KAAgB,OAATE,GACHD,EAAaE,QAAQrC,KAAKY,aAAawB,EAAKvB,IAAKuB,EAAKtB,MACtDsB,EAAOA,EAAKjB,KAEhB,OAAOgB,CACV,CAMDH,eAAAA,CAAgBxB,EAAMV,GAClB,IAAIwC,EAAYtC,KAAKuC,aAAa/B,EAAMV,GAExC,IAAK,IAAI0C,KAASF,EAAW,CAEzB,GADmB9B,EAAKQ,SAAW,EAChBwB,EAAMxB,SAAU,CAC/B,MAAMyB,EAAQzC,KAAKY,aAAa4B,EAAM3B,IAAK2B,EAAM1B,KACjD0B,EAAMxB,SAAWR,EAAKQ,SAAW,EACjCwB,EAAMrB,KAAOX,EACbR,KAAK4B,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACU,IAChD,CACJ,CACJ,CAMDF,YAAAA,CAAa/B,EAAMV,GACf,MAAMwC,EAAY,GAClB,IAAIzB,EAAML,EAAKK,IACXC,EAAMN,EAAKM,IACXb,EAAOD,KAAKC,KACZG,EAAOJ,KAAKI,KAUhB,OARIS,EAAM,GAAGyB,EAAUT,KAAK/B,EAAME,KAAKY,aAAaC,EAAM,EAAGC,KACzDD,EAAMZ,EAAO,GACbqC,EAAUT,KAAK/B,EAAME,KAAKY,aAAaC,EAAM,EAAGC,KAEhDA,EAAM,GAAGwB,EAAUT,KAAK/B,EAAME,KAAKY,aAAaC,EAAKC,EAAM,KAC3DA,EAAMV,EAAO,GACbkC,EAAUT,KAAK/B,EAAME,KAAKY,aAAaC,EAAKC,EAAM,KAE/CwB,EAAUI,QACZC,IAAaA,EAAQzB,aAAeyB,EAAQhB,SAEpD,CAKDJ,cAAAA,CAAezB,GACXA,EAAM8C,MAAK,CAACC,EAAOC,IAAUD,EAAM7B,SAAW8B,EAAM9B,UACvD","file":"dijkstra.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class Dijkstra extends Algorithm {\n    /**@param {Node[]} nodes  */\n    constructor(nodes) {\n        super(nodes);\n\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n        this.startNode = nodes.find((node) => node.is_start);\n        this.finishNode = nodes.find((node) => node.is_finish);\n        this.get_1d_index = (row, col) => row * this.cols + col;\n    }\n\n    solve() {\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        }\n        this.startNode.distance = 0;\n\n        let unvisited_list = this.nodes.slice();\n\n        while (!!unvisited_list.length) {\n            this.sortByDistance(unvisited_list);\n            let closest = unvisited_list.shift();\n            let closestIndex = this.get_1d_index(closest.row, closest.col);\n\n            if (closest.is_wall) continue;\n            if (closest.distance == Infinity) break;\n\n            closest.is_visited = true;\n\n            this.steps.push({ type: \"visited\", indices: [closestIndex] });\n\n            if (closest == this.finishNode) break;\n\n            this.updateNeighbors(closest, this.nodes);\n        }\n\n        this.steps.push({ type: \"finish\", indices: this.dijkstraGetPath() });\n\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        }\n        return this.steps;\n    }\n\n    dijkstraGetPath(current = this.finishNode) {\n        const shortestPath = [];\n        let curr = current;\n\n        while (curr !== null) {\n            shortestPath.unshift(this.get_1d_index(curr.row, curr.col));\n            curr = curr.prev;\n        }\n        return shortestPath;\n    }\n\n    /**\n     * @param {Node} node - Node to update neighbors\n     * @param {Node[]} nodes - The nodes array\n     */\n    updateNeighbors(node, nodes) {\n        let neighbors = this.getNeighbors(node, nodes);\n\n        for (let neigh of neighbors) {\n            let new_distance = node.distance + 1;\n            if (new_distance < neigh.distance) {\n                const index = this.get_1d_index(neigh.row, neigh.col);\n                neigh.distance = node.distance + 1;\n                neigh.prev = node;\n                this.steps.push({ type: \"updated\", indices: [index] });\n            }\n        }\n    }\n\n    /**\n     * @param {Node} node - Node to update neighbors\n     * @param {Node[]} nodes - The nodes array\n     */\n    getNeighbors(node, nodes) {\n        const neighbors = [];\n        let row = node.row;\n        let col = node.col;\n        let rows = this.rows;\n        let cols = this.cols;\n\n        if (row > 0) neighbors.push(nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(nodes[this.get_1d_index(row + 1, col)]);\n\n        if (col > 0) neighbors.push(nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors.filter(\n            (ng_node) => !ng_node.is_visited && !ng_node.is_wall\n        );\n    }\n\n    /**\n     * @param {Node[]} nodes - The nodes array\n     */\n    sortByDistance(nodes) {\n        nodes.sort((node1, node2) => node1.distance - node2.distance);\n    }\n}\n"]}