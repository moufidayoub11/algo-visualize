{"version":3,"sources":["DepthFirstSearch.js"],"names":["Node","Algorithm","DepthFirstSearch","constructor","nodes","super","this","rows","stateManager","getRows","cols","getCols","startNode","find","node","is_start","finishNode","is_finish","get_1d_index","row","col","solve","closedSet","openSet","length","closest","shift","closestIndex","is_visited","is_wall","push","steps","type","indices","updateNeighbors","dfsGetPath","current","shortestPath","curr","unshift","prev","neighbors","getNeighbors","neighbor","index","filter"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,yBAAyBD,UAE1CE,WAAAA,CAAYC,GACRC,MAAMD,GAENE,KAAKC,KAAOD,KAAKE,aAAaC,UAC9BH,KAAKI,KAAOJ,KAAKE,aAAaG,UAC9BL,KAAKM,UAAYR,EAAMS,MAAMC,GAASA,EAAKC,WAC3CT,KAAKU,WAAaZ,EAAMS,MAAMC,GAASA,EAAKG,YAC5CX,KAAKY,aAAe,CAACC,EAAKC,IAAQD,EAAMb,KAAKI,KAAOU,CACvD,CAEDC,KAAAA,GAII,IAHAf,KAAKgB,UAAY,CAAChB,KAAKM,WACvBN,KAAKiB,QAAU,CAACjB,KAAKM,WAEZN,KAAKiB,QAAQC,QAAQ,CAC1B,IAAIC,EAAUnB,KAAKiB,QAAQG,QAC3B,GAAID,GAAWnB,KAAKU,WAAY,MAEhC,IAAIW,EAAerB,KAAKY,aAAaO,EAAQN,IAAKM,EAAQL,KAEtDK,EAAQG,aACRH,EAAQI,UAEZJ,EAAQG,YAAa,EACrBtB,KAAKgB,UAAUQ,KAAKL,GACpBnB,KAAKyB,MAAMD,KAAK,CACZE,KAAM,UACNC,QAAS,CAACN,KAGdrB,KAAK4B,gBAAgBT,IACxB,CAOD,OALAnB,KAAKyB,MAAMD,KAAK,CACZE,KAAM,SACNC,QAAS3B,KAAK6B,eAGX7B,KAAKyB,KACf,CAEDI,UAAAA,CAAWC,EAAU9B,KAAKU,YACtB,MAAMqB,EAAe,GACrB,IAAIC,EAAOF,EAEX,KAAgB,OAATE,GACHD,EAAaE,QAAQjC,KAAKY,aAAaoB,EAAKnB,IAAKmB,EAAKlB,MACtDkB,EAAOA,EAAKE,KAEhB,OAAOH,CACV,CAEDH,eAAAA,CAAgBpB,GACZ,MAAM2B,EAAYnC,KAAKoC,aAAa5B,GAEpC,IAAK,MAAM6B,KAAYF,EAAW,CAC9B,MAAMG,EAAQtC,KAAKY,aAAayB,EAASxB,IAAKwB,EAASvB,KACvDd,KAAKyB,MAAMD,KAAK,CAAEE,KAAM,UAAWC,QAAS,CAACW,KAC7CtC,KAAKiB,QAAQO,KAAKa,GAClBrC,KAAKgB,UAAUQ,KAAKa,EACvB,CACJ,CAEDD,YAAAA,CAAa5B,GAET,MAAM2B,EAAY,IACZtB,IAAEA,EAAFC,IAAOA,GAAQN,GACfP,KAAEA,EAAFG,KAAQA,GAASJ,KAWvB,OATIa,EAAM,GACNsB,EAAUX,KAAKxB,KAAKF,MAAME,KAAKY,aAAaC,EAAM,EAAGC,KACrDD,EAAMZ,EAAO,GACbkC,EAAUX,KAAKxB,KAAKF,MAAME,KAAKY,aAAaC,EAAM,EAAGC,KACrDA,EAAM,GACNqB,EAAUX,KAAKxB,KAAKF,MAAME,KAAKY,aAAaC,EAAKC,EAAM,KACvDA,EAAMV,EAAO,GACb+B,EAAUX,KAAKxB,KAAKF,MAAME,KAAKY,aAAaC,EAAKC,EAAM,KAEpDqB,EAAUI,QACZF,IAAcA,EAASf,aAAee,EAASd,SAEvD","file":"DepthFirstSearch.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class DepthFirstSearch extends Algorithm {\n    /**@param {Node[]} nodes  */\n    constructor(nodes) {\n        super(nodes);\n\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n        this.startNode = nodes.find((node) => node.is_start);\n        this.finishNode = nodes.find((node) => node.is_finish);\n        this.get_1d_index = (row, col) => row * this.cols + col;\n    }\n\n    solve() {\n        this.closedSet = [this.startNode];\n        this.openSet = [this.startNode];\n\n        while (!!this.openSet.length) {\n            let closest = this.openSet.shift();\n            if (closest == this.finishNode) break;\n\n            let closestIndex = this.get_1d_index(closest.row, closest.col);\n\n            if (closest.is_visited) continue;\n            if (closest.is_wall) continue;\n\n            closest.is_visited = true;\n            this.closedSet.push(closest);\n            this.steps.push({\n                type: \"visited\",\n                indices: [closestIndex],\n            });\n\n            this.updateNeighbors(closest);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.dfsGetPath(),\n        });\n\n        return this.steps;\n    }\n\n    dfsGetPath(current = this.finishNode) {\n        const shortestPath = [];\n        let curr = current;\n\n        while (curr !== null) {\n            shortestPath.unshift(this.get_1d_index(curr.row, curr.col));\n            curr = curr.prev;\n        }\n        return shortestPath;\n    }\n\n    updateNeighbors(node) {\n        const neighbors = this.getNeighbors(node);\n\n        for (const neighbor of neighbors) {\n            const index = this.get_1d_index(neighbor.row, neighbor.col);\n            this.steps.push({ type: \"updated\", indices: [index] });\n            this.openSet.push(neighbor);\n            this.closedSet.push(neighbor);\n        }\n    }\n\n    getNeighbors(node) {\n        /**@type {Node[]} */\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors.filter(\n            (neighbor) => !neighbor.is_visited && !neighbor.is_wall\n        );\n    }\n}\n"]}