{"version":3,"sources":["AStar.js"],"names":["Node","Algorithm","Astar","constructor","nodes","super","this","rows","stateManager","getRows","cols","getCols","startNode","find","node","is_start","finishNode","is_finish","get_1d_index","row","col","solve","forEach","distance","Infinity","f","is_visited","prev","heuristic","openSet","slice","length","sortByHeuristic","closest","shift","closestIndex","is_wall","steps","push","type","indices","updateNeighbors","aStarGetPath","node1","node2","Math","abs","current","shortestPath","curr","unshift","neighbors","getNeighbors","neighbor","tentativeDistance","tentativeHeuristic","index","filter","sort"],"mappings":"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","file":"AStar.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class Astar extends Algorithm {\n    /**@param {Node[]} nodes  */\n    constructor(nodes) {\n        super(nodes);\n\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n        this.startNode = nodes.find((node) => node.is_start);\n        this.finishNode = nodes.find((node) => node.is_finish);\n        this.get_1d_index = (row, col) => row * this.cols + col;\n    }\n\n    solve() {\n        this.nodes.forEach((node) => {\n            node.distance = Infinity;\n            node.f = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        });\n\n        this.startNode.distance = 0;\n        this.startNode.f = this.heuristic(this.startNode, this.finishNode);\n\n        this.openSet = this.nodes.slice();\n\n        while (!!this.openSet.length) {\n            this.sortByHeuristic(this.openSet);\n            let closest = this.openSet.shift();\n            if (closest == this.finishNode) break;\n\n            let closestIndex = this.get_1d_index(closest.row, closest.col);\n\n            if (closest.is_visited) continue;\n            if (closest.is_wall) continue;\n\n            if (closest.distance == Infinity) break;\n\n            closest.is_visited = true;\n            this.steps.push({\n                type: \"visited\",\n                indices: [closestIndex],\n            });\n\n            this.updateNeighbors(closest);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.aStarGetPath(),\n        });\n\n        this.nodes.forEach((node) => {\n            node.distance = Infinity;\n            node.f = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        });\n        return this.steps;\n    }\n\n    heuristic(node1, node2) {\n        return (\n            Math.abs(node1.row - node2.row) + Math.abs(node1.col - node2.col)\n        );\n    }\n\n    aStarGetPath(current = this.finishNode) {\n        const shortestPath = [];\n        let curr = current;\n\n        while (curr !== null) {\n            shortestPath.unshift(this.get_1d_index(curr.row, curr.col));\n            curr = curr.prev;\n        }\n        return shortestPath;\n    }\n\n    updateNeighbors(node) {\n        const neighbors = this.getNeighbors(node);\n\n        for (const neighbor of neighbors) {\n            const tentativeDistance = node.distance + 1;\n            const tentativeHeuristic =\n                tentativeDistance + this.heuristic(neighbor, this.finishNode);\n            if (tentativeHeuristic < neighbor.f) {\n                const index = this.get_1d_index(neighbor.row, neighbor.col);\n                neighbor.distance = tentativeDistance;\n                neighbor.prev = node;\n                neighbor.f = tentativeHeuristic;\n\n                this.steps.push({ type: \"updated\", indices: [index] });\n            }\n        }\n    }\n\n    getNeighbors(node) {\n        /**@type {Node[]} */\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors.filter((neighbor) => !neighbor.is_visited);\n    }\n\n    sortByHeuristic(nodes) {\n        nodes.sort((node1, node2) => node1.f - node2.f);\n    }\n}\n"]}