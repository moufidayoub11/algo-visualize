{"version":3,"sources":["bfs.js"],"names":["Node","Algorithm","BreadthFirstSearch","constructor","nodes","super","this","rows","stateManager","getRows","cols","getCols","startNode","find","node","is_start","finishNode","is_finish","get_1d_index","row","col","solve","distance","Infinity","is_visited","prev","queue","length","current","shift","currentIndex","is_wall","steps","push","type","indices","updateNeighbors","bfsGetPath","shortestPath","unshift","neighbors","getNeighbors","neighbor","index","filter"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,2BAA2BD,UAC5CE,WAAAA,CAAYC,GACRC,MAAMD,GACNE,KAAKC,KAAOD,KAAKE,aAAaC,UAC9BH,KAAKI,KAAOJ,KAAKE,aAAaG,UAC9BL,KAAKM,UAAYR,EAAMS,MAAMC,GAASA,EAAKC,WAC3CT,KAAKU,WAAaZ,EAAMS,MAAMC,GAASA,EAAKG,YAC5CX,KAAKY,aAAe,CAACC,EAAKC,IAAQD,EAAMb,KAAKI,KAAOU,CACvD,CAEDC,KAAAA,GACI,IAAK,IAAIP,KAAQR,KAAKF,MAClBU,EAAKQ,SAAWC,IAChBT,EAAKU,YAAa,EAClBV,EAAKW,KAAO,KAIhB,IAFAnB,KAAKoB,MAAQ,CAACpB,KAAKM,WAEVN,KAAKoB,MAAMC,QAAQ,CACxB,IAAIC,EAAUtB,KAAKoB,MAAMG,QAEzB,GAAID,IAAYtB,KAAKU,WAAY,MAEjC,IAAIc,EAAexB,KAAKY,aAAaU,EAAQT,IAAKS,EAAQR,KAEtDQ,EAAQJ,YAAcI,EAAQG,UAElCH,EAAQJ,YAAa,EACrBlB,KAAK0B,MAAMC,KAAK,CACZC,KAAM,UACNC,QAAS,CAACL,KAGdxB,KAAK8B,gBAAgBR,GACxB,CAOD,OALAtB,KAAK0B,MAAMC,KAAK,CACZC,KAAM,SACNC,QAAS7B,KAAK+B,eAGX/B,KAAK0B,KACf,CAEDK,UAAAA,GACI,MAAMC,EAAe,GACrB,IAAIV,EAAUtB,KAAKU,WAEnB,KAAmB,OAAZY,GACHU,EAAaC,QAAQjC,KAAKY,aAAaU,EAAQT,IAAKS,EAAQR,MAC5DQ,EAAUA,EAAQH,KAEtB,OAAOa,CACV,CAEDF,eAAAA,CAAgBtB,GACZ,MAAM0B,EAAYlC,KAAKmC,aAAa3B,GAEpC,IAAK,MAAM4B,KAAYF,EAAW,CAC9B,MAAMG,EAAQrC,KAAKY,aAAawB,EAASvB,IAAKuB,EAAStB,KACvDsB,EAASjB,KAAOX,EAChB4B,EAASpB,UAAY,GACrBhB,KAAK0B,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACQ,KAC7CrC,KAAKoB,MAAMO,KAAKS,EACnB,CACJ,CAEDD,YAAAA,CAAa3B,GACT,MAAM0B,EAAY,IACZrB,IAAEA,EAAFC,IAAOA,GAAQN,GACfP,KAAEA,EAAFG,KAAQA,GAASJ,KAWvB,OATIa,EAAM,GACNqB,EAAUP,KAAK3B,KAAKF,MAAME,KAAKY,aAAaC,EAAM,EAAGC,KACrDD,EAAMZ,EAAO,GACbiC,EAAUP,KAAK3B,KAAKF,MAAME,KAAKY,aAAaC,EAAM,EAAGC,KACrDA,EAAM,GACNoB,EAAUP,KAAK3B,KAAKF,MAAME,KAAKY,aAAaC,EAAKC,EAAM,KACvDA,EAAMV,EAAO,GACb8B,EAAUP,KAAK3B,KAAKF,MAAME,KAAKY,aAAaC,EAAKC,EAAM,KAEpDoB,EAAUI,QACZF,IAAcA,EAASlB,aAAekB,EAASX,SAEvD","file":"bfs.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class BreadthFirstSearch extends Algorithm {\n    constructor(nodes) {\n        super(nodes);\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n        this.startNode = nodes.find((node) => node.is_start);\n        this.finishNode = nodes.find((node) => node.is_finish);\n        this.get_1d_index = (row, col) => row * this.cols + col;\n    }\n\n    solve() {\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        }\n        this.queue = [this.startNode];\n\n        while (!!this.queue.length) {\n            let current = this.queue.shift();\n\n            if (current === this.finishNode) break;\n\n            let currentIndex = this.get_1d_index(current.row, current.col);\n\n            if (current.is_visited || current.is_wall) continue;\n\n            current.is_visited = true;\n            this.steps.push({\n                type: \"visited\",\n                indices: [currentIndex],\n            });\n\n            this.updateNeighbors(current);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.bfsGetPath(),\n        });\n\n        return this.steps;\n    }\n\n    bfsGetPath() {\n        const shortestPath = [];\n        let current = this.finishNode;\n\n        while (current !== null) {\n            shortestPath.unshift(this.get_1d_index(current.row, current.col));\n            current = current.prev;\n        }\n        return shortestPath;\n    }\n\n    updateNeighbors(node) {\n        const neighbors = this.getNeighbors(node);\n\n        for (const neighbor of neighbors) {\n            const index = this.get_1d_index(neighbor.row, neighbor.col);\n            neighbor.prev = node;\n            neighbor.distance = -12;\n            this.steps.push({ type: \"updated\", indices: [index] });\n            this.queue.push(neighbor);\n        }\n    }\n\n    getNeighbors(node) {\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors.filter(\n            (neighbor) => !neighbor.is_visited && !neighbor.is_wall\n        );\n    }\n}\n"]}