import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class Astar extends Algorithm{constructor(s){super(s),this.rows=this.stateManager.getRows(),this.cols=this.stateManager.getCols(),this.startNode=s.find((s=>s.is_start)),this.finishNode=s.find((s=>s.is_finish)),this.get_1d_index=(s,t)=>s*this.cols+t}solve(){for(this.nodes.forEach((s=>{s.distance=1/0,s.f=1/0,s.is_visited=!1,s.prev=null})),this.startNode.distance=0,this.startNode.f=this.heuristic(this.startNode,this.finishNode),this.openSet=this.nodes.slice();this.openSet.length;){this.sortByHeuristic(this.openSet);let s=this.openSet.shift();if(s==this.finishNode)break;let t=this.get_1d_index(s.row,s.col);if(!s.is_visited&&!s.is_wall){if(s.distance==1/0)break;s.is_visited=!0,this.steps.push({type:"visited",indices:[t]}),this.updateNeighbors(s)}}return this.steps.push({type:"finish",indices:this.aStarGetPath()}),this.nodes.forEach((s=>{s.distance=1/0,s.f=1/0,s.is_visited=!1,s.prev=null})),this.steps}heuristic(s,t){return Math.abs(s.row-t.row)+Math.abs(s.col-t.col)}aStarGetPath(s=this.finishNode){const t=[];let i=s;for(;null!==i;)t.unshift(this.get_1d_index(i.row,i.col)),i=i.prev;return t}updateNeighbors(s){const t=this.getNeighbors(s);for(const i of t){const t=s.distance+1,e=t+this.heuristic(i,this.finishNode);if(e<i.f){const h=this.get_1d_index(i.row,i.col);i.distance=t,i.prev=s,i.f=e,this.steps.push({type:"updated",indices:[h]})}}}getNeighbors(s){const t=[],{row:i,col:e}=s,{rows:h,cols:o}=this;return i>0&&t.push(this.nodes[this.get_1d_index(i-1,e)]),i<h-1&&t.push(this.nodes[this.get_1d_index(i+1,e)]),e>0&&t.push(this.nodes[this.get_1d_index(i,e-1)]),e<o-1&&t.push(this.nodes[this.get_1d_index(i,e+1)]),t.filter((s=>!s.is_visited))}sortByHeuristic(s){s.sort(((s,t)=>s.f-t.f))}}
//# sourceMappingURL=AStar.js.map