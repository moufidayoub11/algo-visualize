{"version":3,"sources":["GridAnimator.js"],"names":["StateManager","AlgorithmsManager","Utils","VISITED_COLOR","CLOSED_COLOR","GridAnimator","constructor","this","stateManager","visualize","type","state","getState","nodes","getNodes","nodesElements","getNodeElements","dynamicSleepTime","length","setState","algorithmsManager","steps","dijkstra","aStar","depthFS","breadthFS","gol","step","console","count","performStep","indices","animateVisited","animateUpdated","animateGolGeneration","generation","animateFinish","indice","node","nodeElement","is_finish","is_start","style","backgroundColor","sleep","i","index","then","classList","toggle","is_wall","originalStart","lastElement","contains","manipulateClasses"],"mappings":"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","file":"GridAnimator.js","sourcesContent":["import StateManager from \"../StateManager.js\";\nimport AlgorithmsManager from \"../algorithms/AlgorithmsManager.js\";\nimport Utils from \"../utils/Utils.js\";\n\nconst VISITED_COLOR = \"rgba(0, 0, 66, 0.75)\";\nconst CLOSED_COLOR = \"rgba(0, 190, 218, 0.75)\";\n\nexport default class GridAnimator {\n    constructor() {\n        this.stateManager = new StateManager();\n    }\n\n    async visualize(type) {\n        this.state = this.stateManager.getState();\n        this.nodes = this.stateManager.getNodes();\n        this.nodesElements = this.stateManager.getNodeElements();\n        this.dynamicSleepTime = 500 / this.nodes.length;\n\n        if (this.state || !this.nodes.length || !this.nodesElements.length)\n            return;\n\n        this.stateManager.setState(true);\n\n        const algorithmsManager = new AlgorithmsManager(\n            this.stateManager.getNodes()\n        );\n        let steps = [];\n\n        switch (type) {\n            case \"dijkstra\":\n                steps = algorithmsManager.dijkstra();\n                break;\n            case \"astar\":\n                steps = algorithmsManager.aStar();\n                break;\n            case \"dfs\":\n                steps = algorithmsManager.depthFS();\n                break;\n            case \"bfs\":\n                steps = algorithmsManager.breadthFS();\n                break;\n            case \"gol\":\n                steps = algorithmsManager.gol();\n                break;\n        }\n\n        for (const step of steps) {\n            console.count(\"step\");\n            await this.performStep(step);\n        }\n\n        this.stateManager.setState(false);\n    }\n\n    async performStep(step) {\n        const { type, indices } = step;\n\n        if (type === \"visited\") {\n            await this.animateVisited(indices[0]);\n        } else if (type == \"updated\") {\n            await this.animateUpdated(indices[0]);\n        } else if (type === \"golGeneration\") {\n            await this.animateGolGeneration(step.generation);\n        } else if (type === \"finish\") {\n            await this.animateFinish(indices);\n        }\n    }\n\n    async animateVisited(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (node.is_finish || node.is_start) return;\n        nodeElement.style.backgroundColor = VISITED_COLOR;\n        await Utils.sleep(this.dynamicSleepTime);\n    }\n\n    async animateGolGeneration(generation) {\n        for (let i = 0; i < generation.length; i++) {\n            const { type, index } = generation[i];\n            let node = this.nodes[index];\n            if (node.is_finish || node.is_start) continue;\n            let nodeElement = this.nodesElements[index];\n            Utils.sleep(this.dynamicSleepTime * i * 2).then(() => {\n                nodeElement.classList.toggle(\"node-wall\", type != \"kill\");\n            });\n        }\n    }\n\n    async animateUpdated(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (!node || node.is_finish || node.is_start || node.is_wall) return;\n        nodeElement.style.backgroundColor = CLOSED_COLOR;\n    }\n    async animateFinish(indices) {\n        let originalStart = null;\n        let lastElement = null;\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i];\n            const node = this.nodesElements[index];\n            if (node.classList.contains(\"node-start\")) {\n                originalStart = node;\n            }\n            Utils.manipulateClasses(node, [\"node-path\"]);\n            if (!node.classList.contains(\"node-finish\")) {\n                Utils.manipulateClasses(node, [\"node-start\"]);\n            }\n\n            if (lastElement) {\n                Utils.manipulateClasses(lastElement, [], [\"node-start\"]);\n            }\n\n            lastElement = node;\n            await Utils.sleep(this.dynamicSleepTime * 10);\n        }\n\n        if (lastElement && originalStart) {\n            await Utils.sleep(this.dynamicSleepTime * 10);\n            Utils.manipulateClasses(lastElement, [], [\"node-start\"]);\n            Utils.manipulateClasses(originalStart, [\"node-start\"]);\n        }\n    }\n}\n"]}