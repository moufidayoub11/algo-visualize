{"version":3,"sources":["GridCreator.js"],"names":["StateManager","Node","Utils","VISITED_COLOR","CLOSED_COLOR","GridCreator","constructor","this","stateManager","gridElement","getGridElement","nodes","nodesElements","is_mouse_pressed","add_wall","currently_moving","last_hoverd_node","createGrid","getState","setState","rows","getRows","cols","getCols","createNodes","innerHTML","row","newRow","document","createElement","col","nodeElement","id","className","node","is_start","is_finish","sleep","then","classList","add","push","appendChild","setNodeElements","halfRow","Math","floor","quarterCol","twoThirdCol","i","new_node","setNodes","addRandomWalls","clearGrid","weights","weightedRandom","is_wall","manipulateClasses","handleAlgoChange","newAlgo","currentAlgo","clearPaths","startNode","find","finishNode","startNodeEl","finishNodeEl","toggle","includes","console","log","wallPromises","length","contains","remove","Promise","all","style","backgroundColor","handleEvents","e","event","preventDefault","target","nodeName","parseInt","split","lrow","lcol","lnode"],"mappings":"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","file":"GridCreator.js","sourcesContent":["import StateManager from \"../StateManager.js\";\nimport Node from \"../node/Node.js\";\nimport Utils from \"../utils/Utils.js\";\n\nconst VISITED_COLOR = \"rgba(0, 0, 66, 0.75)\";\nconst CLOSED_COLOR = \"rgba(0, 190, 218, 0.75)\";\n\n/**\n * Represents the creation part of the grid\n */\nexport default class GridCreator {\n    constructor() {\n        this.stateManager = new StateManager();\n\n        this.gridElement = this.stateManager.getGridElement();\n\n        /** @type {Node[]} */\n        this.nodes = [];\n        /** @type {HTMLElement[]} */\n        this.nodesElements = [];\n\n        /**\n         * These are for handling the drawing on the grid\n         */\n        /** @type {boolean} */\n        this.is_mouse_pressed = false;\n        /** @type {boolean} */\n        this.add_wall = false;\n        /** @type {string|null} */\n        this.currently_moving = null;\n        /** @type {HTMLElement|null} */\n        this.last_hoverd_node = null;\n    }\n\n    /**\n     * Creates the grid\n     */\n    createGrid() {\n        if (this.stateManager.getState()) return;\n        this.stateManager.setState(true);\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n\n        this.createNodes();\n\n        const gridElement = this.gridElement;\n\n        gridElement.innerHTML = \"\";\n        this.nodesElements = [];\n\n        for (let row = 0; row < this.rows; row++) {\n            const newRow = document.createElement(\"tr\");\n            for (let col = 0; col < this.cols; col++) {\n                const nodeElement = document.createElement(\"td\");\n\n                nodeElement.id = `node-${row}-${col}`;\n                nodeElement.className = \"node\";\n\n                const node = this.nodes[row * this.cols + col];\n                if (node.is_start || node.is_finish) {\n                    Utils.sleep(250).then(() => {\n                        nodeElement.classList.add(\n                            node.is_start ? \"node-start\" : \"node-finish\"\n                        );\n                    });\n                }\n\n                this.nodesElements.push(nodeElement);\n                newRow.appendChild(nodeElement);\n            }\n\n            gridElement.appendChild(newRow);\n        }\n\n        this.stateManager.setState(false);\n        this.stateManager.setNodeElements(this.nodesElements);\n    }\n\n    /**\n     * Initializes nodes\n     */\n    createNodes() {\n        this.nodes = [];\n\n        const halfRow = Math.floor(this.rows / 2);\n        const quarterCol = Math.floor(this.cols / 4);\n        const twoThirdCol = Math.floor((this.cols * 2) / 3);\n        for (let i = 0; i < this.rows * this.cols; i++) {\n            let row = Math.floor(i / this.cols);\n            let col = i % this.cols;\n            let is_start = row === halfRow && col == quarterCol;\n            let is_finish = row === halfRow && col == twoThirdCol;\n            const new_node = new Node(row, col, is_start, is_finish);\n            this.nodes.push(new_node);\n        }\n\n        this.stateManager.setNodes(this.nodes);\n    }\n\n    async addRandomWalls() {\n        await this.clearGrid();\n        let weights = [\n            [\"obstacle\", 30],\n            [\"nonobstacle\", 100],\n        ];\n        for (let i = 0; i < this.cols * this.rows; i++) {\n            const node = this.nodes[i];\n            const nodeElement = this.nodesElements[i];\n            if (node.is_start || node.is_finish) continue;\n\n            let decision = Utils.weightedRandom(weights);\n            if (decision) {\n                node.is_wall = true;\n                Utils.manipulateClasses(nodeElement, [\"node-wall\"]);\n            }\n        }\n    }\n\n    handleAlgoChange(newAlgo, currentAlgo) {\n        if (this.stateManager.getState()) return;\n        this.clearPaths();\n\n        const startNode = this.nodes.find((node) => node.is_start);\n        const finishNode = this.nodes.find((node) => node.is_finish);\n\n        const startNodeEl =\n            this.nodesElements[startNode.row * this.cols + startNode.col];\n        const finishNodeEl =\n            this.nodesElements[finishNode.row * this.cols + finishNode.col];\n\n        startNodeEl.classList.toggle(\"node-start\", ![\"gol\"].includes(newAlgo));\n        finishNodeEl.classList.toggle(\n            \"node-finish\",\n            ![\"gol\"].includes(newAlgo)\n        );\n\n        console.log(newAlgo);\n        console.log(currentAlgo);\n\n        if ([\"gol\"].includes(currentAlgo) && ![\"gol\"].includes(newAlgo)) {\n            this.clearGrid();\n        }\n    }\n    /**\n     * clear all walls\n     */\n    async clearGrid() {\n        if (this.stateManager.getState()) return;\n        this.stateManager.setState(true);\n\n        this.clearPaths();\n\n        let wallPromises = [];\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            const nodeElement = this.nodesElements[i];\n            if (!node.is_wall && !nodeElement.classList.contains(\"node-wall\"))\n                continue;\n            console.log(\"found wall\");\n            node.is_wall = false;\n            let classList = nodeElement.classList;\n\n            wallPromises.push(\n                Utils.sleep(Math.floor(i)).then(() => {\n                    classList.remove(\"node-wall\");\n                })\n            );\n        }\n        await Promise.all(wallPromises);\n\n        this.stateManager.setState(false);\n    }\n\n    clearPaths() {\n        if (!this.nodes) return;\n\n        for (let i = 0; i < this.nodes.length; i++) {\n            const nodeElement = this.nodesElements[i];\n            if (\n                [VISITED_COLOR, CLOSED_COLOR].includes(\n                    nodeElement.style.backgroundColor\n                )\n            ) {\n                nodeElement.style.backgroundColor = \"var(--ghost-white)\";\n            }\n            nodeElement.classList.remove(\"node-path\");\n        }\n    }\n\n    /**\n     * Handle events of the grid\n     * @param {MouseEvent} e - The Event object\n     * @param {string} event -  Name of the event (\"mousedown\", \"mousemove\", \"mouseup\")\n     */\n    async handleEvents(e, event) {\n        if (this.stateManager.getState()) return;\n        e.preventDefault();\n\n        const target = e.target;\n        if (!target || target.nodeName !== \"TD\") return;\n\n        let row = parseInt(target.id.split(\"-\")[1]);\n        let col = parseInt(target.id.split(\"-\")[2]);\n        let node = this.nodes[row * this.cols + col];\n\n        const classList = target.classList;\n\n        switch (event) {\n            case \"mousedown\":\n                this.is_mouse_pressed = true;\n                this.clearPaths();\n                if (classList.contains(\"node-start\")) {\n                    node.is_start = false;\n                    classList.remove(\"node-start\");\n                    this.currently_moving = \"node-start\";\n                    this.last_hoverd_node = target;\n                } else if (classList.contains(\"node-finish\")) {\n                    node.is_finish = false;\n                    classList.remove(\"node-finish\");\n                    this.currently_moving = \"node-finish\";\n                    this.last_hoverd_node = target;\n                } else {\n                    this.add_wall = !classList.contains(\"node-wall\");\n                    classList.toggle(\"node-wall\", this.add_wall);\n                    node.is_wall = this.add_wall;\n                }\n                break;\n\n            case \"mousemove\":\n                if (!this.is_mouse_pressed) return;\n                if (this.currently_moving) {\n                    if (this.last_hoverd_node) {\n                        this.last_hoverd_node.classList.remove(\n                            this.currently_moving\n                        );\n                    }\n                    classList.add(this.currently_moving);\n                    this.last_hoverd_node = target;\n                } else if (\n                    !(\n                        classList.contains(\"node-start\") ||\n                        classList.contains(\"node-finish\")\n                    )\n                ) {\n                    node.is_wall = this.add_wall;\n                    classList.toggle(\"node-wall\", this.add_wall);\n                }\n                break;\n\n            case \"mouseup\":\n                this.is_mouse_pressed = false;\n                this.add_wall = false;\n\n                if (this.currently_moving && this.last_hoverd_node) {\n                    let lrow = parseInt(this.last_hoverd_node.id.split(\"-\")[1]);\n                    let lcol = parseInt(this.last_hoverd_node.id.split(\"-\")[2]);\n                    const lnode = this.nodes[lrow * this.cols + lcol];\n                    if (this.last_hoverd_node.classList.contains(\"node-wall\")) {\n                        lnode.is_wall = false;\n                        this.last_hoverd_node.classList.remove(\"node-wall\");\n                    }\n                    lnode.is_start = this.currently_moving == \"node-start\";\n                    lnode.is_finish = this.currently_moving == \"node-finish\";\n                    this.last_hoverd_node.classList.add(this.currently_moving);\n                }\n\n                this.currently_moving = null;\n                this.last_hoverd_node = null;\n\n                break;\n        }\n    }\n}\n"]}